package com.harris.challenge.brata.tools;

import com.harris.challenge.brata.R;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.Vibrator;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.ToggleButton;

import java.util.*;


// Activity to control vibration generated by the Android device
public class CountdownActivity extends Activity
{   
	// Constants
	final int MILLISECONDS_IN_SECOND = 1000;
	final int MINUTES_TO_MILLISECONDS = 60 * 1000;
	static final int INDEFINITE_PERIOD = 1000000;
    
	// Handler used for periodic updates
    static Handler handler = new Handler();
    
    // Logic variables
    static boolean timerStarted = false;
    static boolean timerZeroReset = true;
    static boolean isVibrating = false;
    static boolean isCountdownTimerTicking = false;
    static int timerPeriod = INDEFINITE_PERIOD;
    static long startTime;
    static long pauseTime;
    
    // Vibrator service
    Vibrator vibratorService;
    
    // Android widgets
	EditText editTimer;
	ToggleButton buttonTimer, buttonCountdown;
	TextView textElapsed;
    
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
    	super.onCreate(savedInstanceState);
    	setContentView(R.layout.activity_countdown);

    	initializeView();
    }
    
	/**
     * Initialize all android widgets
     */ 
	public void initializeView()
	{
		vibratorService = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);
		
		editTimer = (EditText)findViewById(R.id.EditTimerA);
		buttonTimer = (ToggleButton)findViewById(R.id.ButtonTimerA);
		buttonCountdown = (ToggleButton)findViewById(R.id.ButtonCountdown);
		textElapsed = (TextView)findViewById(R.id.TextCountdown);
		
		// Setup the timer button to enable or disable the vibration timer
		View.OnClickListener timerEnabled = new OnClickListener() {
			@Override
    		public void onClick(View view) {
				ToggleButton clickedButton = (ToggleButton)view;
				boolean timerIsActivating = clickedButton.isChecked();
				
				deactivateTimers();
				clickedButton.setChecked(timerIsActivating);
				// if activating start the timer;  Start the update process
    			if(timerIsActivating)
    			{
    				switch(view.getId())
    				{
    				case R.id.ButtonTimerA:
    					timerPeriod = Integer.parseInt(editTimer.getText().toString());
    					break;
    				};
    			}
    			else
    			{
    				timerPeriod = INDEFINITE_PERIOD;
    			}
			}
		};
		buttonTimer.setOnClickListener(timerEnabled);
		
		// Set the countdown button to react when starting or stopping
		buttonCountdown.setOnClickListener(new OnClickListener() {
			@Override
    		public void onClick(View v) {
				boolean countdownTimerIsStarting = buttonCountdown.isChecked();
				isCountdownTimerTicking = countdownTimerIsStarting;
				vibratorService.cancel();
				
				// if activating start the timer;  Start the update process
    			if(countdownTimerIsStarting)
    			{
    				startTime = (new Date()).getTime();
    				handler.postDelayed(tickUpdate, 0);
    			}
    			else
    			{
    				buttonCountdown.setChecked(false);
    			}
    			
    			// Do not allow changes to the timer period after being started; Enable if stopped
    			editTimer.setEnabled(isCountdownTimerTicking == false);
    		}
		});
		
		if(isCountdownTimerTicking)
		{
			buttonCountdown.setChecked(true);
			buttonTimer.setChecked(timerPeriod != INDEFINITE_PERIOD);
			editTimer.setEnabled(isCountdownTimerTicking == false);
			editTimer.setText(String.valueOf(timerPeriod));
		}
	}
	
	/**
     * Helper function to disable the active vibration timer
     */   
	void deactivateTimers()
	{
		timerPeriod = INDEFINITE_PERIOD;
		buttonTimer.setChecked(false);
	}
	
    /**
     * This function is used to periodically update the UI
     */    
	Runnable tickUpdate = new Runnable() {
		public void run() {
			// if timer is running
			if(isCountdownTimerTicking)
			{
				// Update the text for the timer
				int secondsElapsed = (int)((new Date()).getTime() - startTime) / MILLISECONDS_IN_SECOND;
				textElapsed.setText(String.format("%3d", secondsElapsed)+" secs");
				
				// Vibrate for 1 second every timer period;  Don't reactivate more than once a second
				if(secondsElapsed % timerPeriod == 0 && isVibrating == false && buttonTimer.isChecked())
				{
					vibratorService.vibrate(1000);
				}
				isVibrating = (secondsElapsed % timerPeriod == 0);
				
				// Finally repost this function to run periodically
				handler.postDelayed(tickUpdate, 25);
			}
		}
	};
	

}